---
layout:     post                        # 使用的布局（不需要改）
title:      动态规划                    # 标题 
subtitle:   求解最优化问题的一种途径、一种方法，而不是一种算法                            #副标题
date:       2020-01-08                  # 时间
author:     DSword                      # 作者
header-img: img/road/road_1.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 算法
    - 动态规划
---

#   1 动态规划

##  1.1 概念意义

动态规划是运筹学的一个分支，是求解决策过程的最优化的数学方法。
动态规划程序设计是对解最优化问题的一种途径、一种方法，而不是一种特殊算法。

##  1.2 基本思想：

动态规划算法与分治法类似，其基本思想也是讲待求解问题分解成若干个子问题，
先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适用
于动态规划求解的问题，经分解得到子问题往往不是互相独立问题的答案，而在需要
时再找出已经求得的答案，这样就可以避免大量的重复性计算，节省时间。

##  1.3 使用情况：

能够采用动态规划求解问题的一般具有3个特性：
1. 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，那么该问题具有
最优子结构，满足最优化原理。
2. 无后效性：将各阶段按照一定的次序排列好之后，对于某个给定的阶段，它以前各
阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。意思就是说，某一
阶段状态一旦确定，就不受这个状态以后的决策的影响；某状态以后的过程不会影响以前
的状态，只与当前状态有关。
3. 有重叠子问题：即子问题之间不是独立的，一个子问题在下一阶段决策中可能被多次使
用。（该性质不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法桶其他
算法就没有什么优势。）

##  1.4 动态规划分类
    
动态规划一般可分为线性动规、区域动规、树形动规、背包动规等
       
- 线性动规：拦截导弹、合唱队形、挖地雷、建学校、剑客决斗等
- 区域动规：石子合并、加分二叉树、统计单词个数、炮兵布阵等
- 树形动规：贪吃蛇、二分查找树、聚会的欢乐、数字三角形等
- 背包问题：01背包问题、完全背包问题、分组背包问题、二维背包、装箱问题、挤牛奶等
       
##  1.5 应用实例：
最短路径问题、项目管理、网络流优化等


#   2 示例1：上楼梯

##  2.1 题目：
有一座高度是10级台阶的楼梯，从下往上走，每跨一步只能向上1级或者2级台阶。要求用程序来求出一共有多少种走法。

##  2.2 方法1：暴力手段

我们可以使用排列组合的思想，写一个多层嵌套循环遍历出所有的可能性。

但是这种方法属于暴力手段。时间复杂度是指数级的。

##  2.3 方法2：动态规划

### 2.3.1 问题建模

1.第十层：可以从第九层一步到达、可以从第八层两步到达。故X(10) = X(9) + X(8)

2.第九层：可以从第八层一步到达、可以从第七层两步到达。故X(9) = X(8) + X(7)

3.第八层：可以从第七层一步到达、可以从第六层两步到达。故X(8) = X(7) + X(6)

。。。

从上面可以看出，我们正在把一个复杂的问题分阶段进行简化，逐步简化成简单的问题。这个就是动态规划的思路。

所以此问题的公式：（X(N)是每一层需要走的步数的可能数量）

    X(1) = 1                n=1
    X(2) = 2                n=2
    X(n) = X(n-1) + X(n-2)  n>=3

> 动态规划中包含三个重要的概念：最优子结构、边界、状态转移公式
>
> 上面的X(10)的X(9)、X(8)两个就是最优子结构，X(1)、X(2)就是边界，X(n)就是状态转移公式
    
### 2.3.2 求解问题

- 递归求解

```
int getClimbingWays(int n) {
    if(n < 1) {
        return 0;
    }
    if(n == 1) {
        return 1;
    }
    if(n == 2) {
        return 2;
    }
    return getClimbingWays(n-1) + getClimbingWays(n-2);
} 
```

此方法时间复杂度近视于O(2^N)。

- 备忘录算法
```
int getClimbingWays(int n,HashMap<Integer,Integer> map) {
    if(n < 1) {
        return 0;
    }
    if(n == 1) {
        return 1;
    }
    if(n == 2) {
        return 2;
    }
    if(map.contains(n)) {
        return map.get(n);
    } else {
        int value = getClimbingWays(n-1) + getClimbingWays(n-2);
        map.put(n,value);
        return value;
    }
} 
```
其中map就是一个备忘录。每当需要计算F(n)的时候，都会首先从map中寻找匹配元素。如果map中存在，
就直接返回结果；如果map中不存在，就计算出结果，存入到备忘录中。

时间复杂度：O(N)
>因为在递归求解的时候，有很多都是重复计算，而且越往下重复越多。所以我们
>
>每次都将不同参数的计算结果存入哈希表中，当遇到相同参数的时候，先从哈希
>
>表中取出结果。这种暂存计算结果的方式叫做备忘录算法。


- 动态规划
从下而上，从简单到复杂。（递归：从复杂到简单）
    
        台阶数	1	2	3	4	5	6	7	8	9	10
        走法数	1	2	3	5	8	13	21	34	55	89
        										
        	1									
        										
        		2								
        										
        	1	2	3							
        										
        		2	3	5						
        										
        			3	5	8					
        										
        				5	8	13				
        										
        					8	13	21			
        										
        						13	21	34		
        										
        							21	34	55	
        										
        								34	55	89



如图，我们可以使用一个表格来表示。（因为我暂时不知道怎么上传图片，就先这样~_~....）

除了第一行和第二行，下面的每行都是前面两个的最优解的和。这样，每一次迭代过程中，
我们只需要保留之前的两个状态，就可以推导出新的状态。而不需要想备忘录算法那样保留
全部的子状态。

```
int getClimbingWays(int n) {
    if ( n < 1 ) return 0;
    if ( n == 1 ) return 1;
    if ( n == 2 ) return 2;
    int a = 1;
    int b = 2;
    int temp = 0;
    for (int i=3; i<=n; i++) {
        temp = a + b;
        a = b;
        b = temp;
    }
    return temp;
}
```
此时的时间复杂度：O(N),空间复杂度为O(1)（因为只用了两三个变量）


##  3 示例2：国王和金矿

##  3.1 题目
有一个国家发现了5座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人数也不同。参与挖
矿工人的总数是10人。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。要求用程
序求解出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？

            金矿1	金矿2	金矿3	金矿4	金矿5
    金量	400	500	200	300	350
    人数	5	5	3	4	3


##  3.2 方法1：暴力手段

我们可以使用排列组合的思想，每座金矿只有挖与不挖，因为本题目有五座金矿，所以排列组合就有
2^5中选择。（N中就有2^N选择）之后我们队所有可能性遍历，排除那些使用工人数超额的选择，在剩下的
选择里面挑选出获取金币数量最多的选择。

时间复杂度：O(2^N)。排列组合的时间复杂度是指数级的！！！

##  3.3 方法2：动态规划

### 3.3.1   问题建模

1.10人五个金矿：取 10人4个金矿最优解、5金矿金数+7人4金矿最优解   的最大值

2.10人四个金矿：取 10人3个金矿最优解、4金矿金数+6人3金矿最优解   的最大值
3.7人四个金矿：取7人3个金矿最优解、4金矿金数+3认可3金矿最优解    的最大值
。。。


。。。

从上面可以看出，我们正在把一个复杂的问题分阶段进行简化，逐步简化成简单的问题。这个就是动态规划的思路。

所以此问题的公式：
（假设金矿数量设置为N，工人数设置为W，P[n]是每个金矿需要花费人数、G[n]是每个金矿可以产出的金子数量，F(N,W)为从前往后N个金矿W人的产出金子数量的最优解）

    F(5,10) = Max( F(4,10), F(4,10 - P[4]) + G[4])              = Max( F(4,10) , F(4,7) + 350)          F(4,10)、F(4,7)
    
    F(4,10) = Max( F(3,10), F(3,10 - P[3]) + G[3])              = Max( F(3,10) , F(3,6) + 300)          F(3,10)、F(3,6)
    F(4,7)  = Max( F(3,7),  F(3,7  - P[3]) + G[3])              = Max( F(3,7)  , F(3,3) + 300)          F(3,7)、F(3,3)
    
    F(3,10) = Max( F(2,10), F(2,10 - P[2]) + G[2])              = Max( F(2,10) , F(2,7) + 200)          F(2,10)、F(2,7)
    F(3,6)  = Max( F(2,6),  F(2,6  - P[2]) + G[2])              = Max( F(2,6)  , F(2,3) + 200)          F(2,6)、F(2,3)
    F(3,7)  = Max( F(2,7),  F(2,7  - P[2]) + G[2])              = Max( F(2,7)  , F(2,4) + 200)          F(2,7)、F(2,4)
    F(3,3)  = Max( F(2,3),  F(2,3  - P[2]) + G[2])              = Max( F(2,3)  , F(2,0) + 200)          F(2,3)、F(2,0)
    
    F(2,10) = Max( F(1,10), F(1,10 - P[1]) + G[1])              = Max( F(1,10) , F(1,5) + 500)          F(1,10)、F(1,5)
    F(2,7)  = Max( F(1,7),  F(1,7  - P[1]) + G[1])              = Max( F(1,7)  , F(1,2) + 500)          F(1,7)、F(1,2)
    F(2,6)  = Max( F(1,6),  F(1,6  - P[1]) + G[1])              = Max( F(1,6)  , F(1,1) + 500)          F(1,6)、F(1,1)
    F(2,3)  = F(1,3)    (W < P[n-1]     3<5)                                                            F(1,3)
    F(2,4)  = F(1,4)    (W < P[n-1]     3<5)                                                            F(1,4)
    F(2,0)  = F(1,0)    (W < P[n-1]     0<5)                                                            F(1,0)
    
    F(1,10) = G[0] = 400      (W >= P[n-1]     10>=5)
    F(1,7)  = G[0] = 400      (W >= P[n-1]     7>=5)
    F(1,6)  = G[0] = 400      (W >= P[n-1]     6>=5)
    F(1,5)  = G[0] = 400      (W >= P[n-1]     5>=5)
    F(1,4)  = 0               (W < P[n-1]      4<5)
    F(1,3)  = 0               (W < P[n-1]      3<5)
    F(1,2)  = 0               (W < P[n-1]      2<5)
    F(1,1)  = 0               (W < P[n-1]      1<5)
    F(1,0)  = 0               (W < P[n-1]      0<5)
    

故我们可以得到状态转移方程：

    F(n,w) = 0                                              (n<=1,w<P[0])
    F(n,w) = G[0]                                           (n==1,s>=P[0])
    F(n,w) = F(n-1,w)                                       (n>1,w<P[n-1])
    F(n,w) = Max(F(n-1,w), F(n-1,w-P[n-1] + G[n-1]))        (n>1,w>=P[n-1])

> 动态规划中包含三个重要的概念：最优子结构、边界、状态转移公式
>
> 上面的X(10)的X(9)、X(8)两个就是最优子结构，X(1)、X(2)就是边界，X(n)就是状态转移公式
    

### 3.3.2   求解问题

- 递归求解
将状态转移方程翻译成递归程序，递归的流程类似于一颗高度为N的二叉树。因为其本质上是一个排列组合，
所以该方法的时间复杂度是O(2^N)。

- 备忘录算法
在递归的基础上，将所有的不相同的参数的结果都存放在一个HashMap容器中，HashMap的key是一个包含金矿
数量N和工人数W的对象，value是最优解的金矿数。这样当我们需要计算某个已经计算过结果的参数的时候，
我们可以直接在HashMap中查询到结果。

时间复杂度：O(n*w)

- 动态规划
```
int int[] getMostGold(int n,int w,int[] g,int[] p) {
    int[] preResults = new int[p.length];
    int[] results = new int[p.length];
    
    //填充边界格子的值
    for (int i=0; i<=n; i++) {
        if(i < P[0]) {
            preResults[i] = 0;
        } else {
            preResults[i] = g[0];
        }
    }
    
    //填充其余格子的值，外层循环是金矿数量，内存循环是工人数
    for (int i=0; i<n; i++) {
        for (int j=0; j<w; j++) {
            if(j < p[i]) {
                results[j] = preResults[j];
            } else {
                results[j] = Math.max(preResults[j],preResults[j-p[i]]+g[i]);
            }
        }
        
        preResults = results;
    }
    
    return results[n];
}
```
































