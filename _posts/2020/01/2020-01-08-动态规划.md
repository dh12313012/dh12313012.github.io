---
layout:     post                        # 使用的布局（不需要改）
title:      动态规划                    # 标题 
subtitle:   求解最优化问题的一种途径、一种方法，而不是一种算法                            #副标题
date:       2020-01-08                  # 时间
author:     DSword                      # 作者
header-img: img/road/road_3.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 算法
    - 动态规划
---

#   1 动态规划

##  1.1 概念意义

动态规划是运筹学的一个分支，是求解决策过程的最优化的数学方法。
动态规划程序设计是对解最优化问题的一种途径、一种方法，而不是一种特殊算法。

##  1.2 基本思想：

动态规划算法与分治法类似，其基本思想也是讲待求解问题分解成若干个子问题，
先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适用
于动态规划求解的问题，经分解得到子问题往往不是互相独立问题的答案，而在需要
时再找出已经求得的答案，这样就可以避免大量的重复性计算，节省时间。

##  1.3 使用情况：

能够采用动态规划求解问题的一般具有3个特性：
1. 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，那么该问题具有
最优子结构，满足最优化原理。
2. 无后效性：将各阶段按照一定的次序排列好之后，对于某个给定的阶段，它以前各
阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。意思就是说，某一
阶段状态一旦确定，就不受这个状态以后的决策的影响；某状态以后的过程不会影响以前
的状态，只与当前状态有关。
3. 有重叠子问题：即子问题之间不是独立的，一个子问题在下一阶段决策中可能被多次使
用。（该性质不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法桶其他
算法就没有什么优势。）

##  1.4 动态规划分类
    
动态规划一般可分为线性动规、区域动规、树形动规、背包动规等
       
- 线性动规：拦截导弹、合唱队形、挖地雷、建学校、剑客决斗等
- 区域动规：石子合并、加分二叉树、统计单词个数、炮兵布阵等
- 树形动规：贪吃蛇、二分查找树、聚会的欢乐、数字三角形等
- 背包问题：01背包问题、完全背包问题、分组背包问题、二维背包、装箱问题、挤牛奶等
       
##  1.5 应用实例：
最短路径问题、项目管理、网络流优化等


#   2 示例1

##  2.1 题目：
有一座高度是10级台阶的楼梯，从下往上走，每跨一步只能向上1级或者2级台阶。要求用程序来求出一共有多少种走法。

##  2.2 方法1：暴力手段

我们可以使用排列组合的思想，写一个多层嵌套循环遍历出所有的可能性。

但是这种方法属于暴力手段。时间复杂度是指数级的。

##  2.3 方法2：动态规划

### 2.3.1 问题建模

1.第十层：可以从第九层一步到达、可以从第八层两步到达。故X(10) = X(9) + X(8)

2.第九层：可以从第八层一步到达、可以从第七层两步到达。故X(9) = X(8) + X(7)

3.第八层：可以从第七层一步到达、可以从第六层两步到达。故X(8) = X(7) + X(6)

。。。

从上面可以看出，我们正在把一个复杂的问题分阶段进行简化，逐步简化成简单的问题。这个就是动态规划的思路。

所以此问题的公式：

    X(1) = 1                n=1
    X(2) = 2                n=2
    X(n) = X(n-1) + X(n-2)  n>=3

> 动态规划中包含三个重要的概念：最优子结构、边界、状态转移公式
>
> 上面的X(10)的X(9)、X(8)两个就是最优子结构，X(1)、X(2)就是边界，X(n)就是状态转移公式
    
### 2.3.2 求解问题

- 递归求解

```
int getClimbingWays(int n) {
    if(n < 1) {
        return 0;
    }
    if(n == 1) {
        return 1;
    }
    if(n == 2) {
        return 2;
    }
    return getClimbingWays(n-1) + getClimbingWays(n-2);
} 
```

此方法时间复杂度近视于O(2^N)。

- 备忘录算法
```
int getClimbingWays(int n,HashMap<Integer,Integer> map) {
    if(n < 1) {
        return 0;
    }
    if(n == 1) {
        return 1;
    }
    if(n == 2) {
        return 2;
    }
    if(map.contains(n)) {
        return map.get(n);
    } else {
        int value = getClimbingWays(n-1) + getClimbingWays(n-2);
        map.put(n,value);
        return value;
    }
} 
```
其中map就是一个备忘录。每当需要计算F(n)的时候，都会首先从map中寻找匹配元素。如果map中存在，
就直接返回结果；如果map中不存在，就计算出结果，存入到备忘录中。

时间复杂度：O(N)
>因为在递归求解的时候，有很多都是重复计算，而且越往下重复越多。所以我们
>
>每次都将不同参数的计算结果存入哈希表中，当遇到相同参数的时候，先从哈希
>
>表中取出结果。这种暂存计算结果的方式叫做备忘录算法。


- 动态规划
从下而上，从简单到复杂。（递归：从复杂到简单）

![动态规划]("http://dh12313012.github.io/image/file/dongtaiguihua_1.png")



































